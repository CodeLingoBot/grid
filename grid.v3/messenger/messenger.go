package messenger

import (
	"bytes"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"sync"
	"time"

	etcdv3 "github.com/coreos/etcd/clientv3"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
)

const Ack = "__ACK__"

var (
	ErrInvalidAddress        = fmt.Errorf("invalid hostname")
	ErrContextFinished       = fmt.Errorf("context finished")
	ErrReceiverBusy          = fmt.Errorf("receiver busy")
	ErrAlreadySubscribed     = fmt.Errorf("already subscribed")
	ErrUnknownHost           = fmt.Errorf("unknown host")
	ErrUnknownReceiver       = fmt.Errorf("unknown receiver")
	ErrInvalidRegistration   = fmt.Errorf("invalid registration")
	ErrInvalidDeregistration = fmt.Errorf("invalid deregistration")
)

type receiverRecord struct {
	Address string `json:"address"`
}

type Envelope struct {
	Msg      interface{}
	response chan []byte
}

func (env *Envelope) Ack() {
	if env.response == nil {
		panic("onlyreceived envelopes may call ack")
	}
	env.Respond(Ack)
}

func (env *Envelope) Respond(msg interface{}) error {
	if env.response == nil {
		panic("only received envelopes may call respond")
	}

	res := &Envelope{
		Msg: msg,
	}

	// Encode the message here, eg: in the Envelope, rather
	// than in Nexus, because it should be done by the
	// receiver's go-routine, otherwise there is a risk
	// that pointers in the message might actuall need
	// locking to be read-safe.
	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	err := enc.Encode(res)
	if err != nil {
		return err
	}

	// Send the response bytes. Again, the bytes need
	// to be generated by the receiver's go-routine.
	env.response <- buf.Bytes()
	return nil
}

type Subscription struct {
	mailbox chan *Envelope
	cleanup func() error
}

func (s *Subscription) Mailbox() <-chan *Envelope {
	return s.mailbox
}

func (s *Subscription) Unsubscribe() error {
	return s.cleanup()
}

func New(address string, etcdServers []string) (*Nexus, error) {
	if address == "" {
		return nil, ErrInvalidAddress
	}
	cfg := etcdv3.Config{
		Endpoints: etcdServers,
	}
	client, err := etcdv3.New(cfg)
	if err != nil {
		return nil, err
	}
	return &Nexus{
		mu:        sync.Mutex{},
		kv:        etcdv3.NewKV(client),
		address:   address,
		clients:   make(map[string]WireClient),
		addresses: make(map[string]string),
		listeners: make(map[string]*Subscription),
	}, nil
}

type Nexus struct {
	mu        sync.Mutex
	kv        etcdv3.KV
	address   string
	clients   map[string]WireClient
	addresses map[string]string
	listeners map[string]*Subscription
}

func (nx *Nexus) Serve() error {
	lis, err := net.Listen("tcp", nx.address)
	if err != nil {
		return err
	}
	grpcServer := grpc.NewServer()
	RegisterWireServer(grpcServer, nx)
	return grpcServer.Serve(lis)
}

func (nx *Nexus) Process(c context.Context, req *Gram) (*Gram, error) {
	sub, err := nx.subscription(req.Receiver)
	if err != nil {
		return nil, err
	}

	// Write the bytes of the request into the byte
	// buffer for decoding.
	var buf bytes.Buffer
	n, err := buf.Write(req.Data)
	if err != nil {
		return nil, err
	}
	if n != len(req.Data) {
		return nil, io.ErrUnexpectedEOF
	}

	// Decode the request into an actual
	// type.
	env := &Envelope{}
	dec := gob.NewDecoder(&buf)
	err = dec.Decode(env)
	if err != nil {
		return nil, err
	}
	env.response = make(chan []byte)

	// Send the filled envelope to the actual
	// receiver.
	select {
	case sub.mailbox <- env:
	default:
		return nil, ErrReceiverBusy
	}

	// Wait for the receiver to send back a
	// reply, or the context to finish.
	select {
	case <-c.Done():
		return nil, ErrContextFinished
	case data := <-env.response:
		return &Gram{
			Data: data,
		}, nil
	}
}

func (nx *Nexus) Request(c context.Context, namespace, receiver string, msg interface{}) (*Envelope, error) {
	env := &Envelope{
		Msg: msg,
	}

	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	err := enc.Encode(env)
	if err != nil {
		return nil, err
	}

	client, err := nx.client(c, namespace, receiver)
	if err != nil {
		return nil, err
	}

	req := &Gram{
		Ver:      Gram_V1,
		Enc:      Gram_Gob,
		Data:     buf.Bytes(),
		Receiver: receiver,
	}
	res, err := client.Process(c, req)
	if err != nil {
		return nil, err
	}

	buf.Reset()
	n, err := buf.Write(res.Data)
	if err != nil {
		return nil, err
	}
	if n != len(res.Data) {
		return nil, io.ErrUnexpectedEOF
	}

	env = &Envelope{}
	dec := gob.NewDecoder(&buf)
	err = dec.Decode(env)
	if err != nil {
		return nil, err
	}

	return env, nil
}

func (nx *Nexus) Subscribe(c context.Context, namespace, receiver string, mailboxSize int) (*Subscription, error) {
	nx.mu.Lock()
	defer nx.mu.Unlock()

	_, ok := nx.listeners[receiver]
	if !ok {
		err := nx.register(c, namespace, receiver)
		if err != nil {
			return nil, err
		}
		mailbox := make(chan *Envelope, mailboxSize)
		cleanup := func() error {
			nx.mu.Lock()
			defer nx.mu.Unlock()
			close(mailbox)
			delete(nx.listeners, receiver)
			return nx.deregister(c, namespace, receiver)
		}
		sub := &Subscription{
			mailbox: mailbox,
			cleanup: cleanup,
		}
		nx.listeners[receiver] = sub
		nx.addresses[receiver] = nx.address
		return sub, nil
	}

	return nil, ErrAlreadySubscribed
}

func (nx *Nexus) subscription(receiver string) (*Subscription, error) {
	nx.mu.Lock()
	defer nx.mu.Unlock()

	sub, ok := nx.listeners[receiver]
	if !ok {
		return nil, ErrUnknownReceiver
	}
	return sub, nil
}

func (nx *Nexus) client(c context.Context, namespace, receiver string) (WireClient, error) {
	nx.mu.Lock()
	defer nx.mu.Unlock()

	address, ok := nx.addresses[receiver]
	if !ok {
		address, err := nx.discover(c, namespace, receiver)
		if err != nil {
			return nil, err
		}
		nx.addresses[receiver] = address
	}

	client, ok := nx.clients[address]
	if !ok {
		conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBackoffMaxDelay(1*time.Minute), grpc.WithBlock())
		if err != nil {
			return nil, err
		}
		client = NewWireClient(conn)
		nx.clients[address] = client
	}
	return client, nil
}

func (nx *Nexus) discover(c context.Context, namespace, receiver string) (string, error) {
	key := makeKey(namespace, receiver)
	res, err := nx.kv.Get(c, key)
	if err != nil {
		return "", err
	}
	if res == nil || len(res.Kvs) == 0 {
		return "", ErrUnknownReceiver
	}
	if len(res.Kvs) > 1 {
		return "", ErrInvalidRegistration
	}
	rec := &receiverRecord{}
	err = json.Unmarshal(res.Kvs[0].Value, rec)
	if err != nil {
		return "", err
	}
	return rec.Address, nil
}

func (nx *Nexus) register(c context.Context, namespace, receiver string) error {
	key := makeKey(namespace, receiver)
	_, err := nx.kv.Get(c, key)
	if err != nil {
		return err
	}
	value, err := json.Marshal(&receiverRecord{Address: nx.address})
	if err != nil {
		return err
	}
	txnRes, err := nx.kv.Txn(c).
		If(etcdv3.Compare(etcdv3.Version(key), "=", 0)).
		Then(etcdv3.OpPut(key, string(value))).
		Commit()
	if err != nil {
		return err
	}
	if !txnRes.Succeeded {
		return ErrInvalidRegistration
	}
	return nil
}

func (nx *Nexus) deregister(c context.Context, namespace, receiver string) error {
	key := makeKey(namespace, receiver)
	var version int64
	res, err := nx.kv.Get(c, key)
	if err != nil {
		return err
	}
	if res != nil && len(res.Kvs) == 1 {
		version = res.Kvs[0].Version
	} else {
		return ErrInvalidRegistration
	}
	rec := &receiverRecord{}
	err = json.Unmarshal(res.Kvs[0].Value, rec)
	if err != nil {
		return err
	}
	if rec.Address != nx.address {
		return ErrInvalidDeregistration
	}
	txnRes, err := nx.kv.Txn(c).
		If(etcdv3.Compare(etcdv3.Version(key), "=", version)).
		Then(etcdv3.OpDelete(key)).
		Commit()
	if err != nil {
		return err
	}
	if !txnRes.Succeeded {
		return ErrInvalidDeregistration
	}
	return nil
}

func makeKey(namespace, receiver string) string {
	return fmt.Sprintf("/%v/%v", namespace, receiver)
}
