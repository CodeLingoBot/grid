package messenger

import (
	"bytes"
	"encoding/gob"
	"fmt"
	"io"
	"net"
	"sync"
	"time"

	"github.com/lytics/grid/grid.v3/discovery"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
)

const Ack = "__ACK__"

var (
	ErrInvalidAddress    = fmt.Errorf("invalid hostname")
	ErrContextFinished   = fmt.Errorf("context finished")
	ErrReceiverBusy      = fmt.Errorf("receiver busy")
	ErrAlreadySubscribed = fmt.Errorf("already subscribed")
	ErrUnknownHost       = fmt.Errorf("unknown host")
	ErrUnknownReceiver   = fmt.Errorf("unknown receiver")
)

type clientAndConn struct {
	conn   *grpc.ClientConn
	client WireClient
}

type Envelope struct {
	Msg      interface{}
	response chan []byte
}

func (env *Envelope) Ack() {
	if env.response == nil {
		panic("onlyreceived envelopes may call ack")
	}
	env.Respond(Ack)
}

func (env *Envelope) Respond(msg interface{}) error {
	if env.response == nil {
		panic("only received envelopes may call respond")
	}

	res := &Envelope{
		Msg: msg,
	}

	// Encode the message here, eg: in the Envelope, rather
	// than in Nexus, because it should be done by the
	// receiver's go-routine, otherwise there is a risk
	// that pointers in the message might actuall need
	// locking to be read-safe.
	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	err := enc.Encode(res)
	if err != nil {
		return err
	}

	// Send the response bytes. Again, the bytes need
	// to be generated by the receiver's go-routine.
	env.response <- buf.Bytes()
	return nil
}

type Subscription struct {
	mailbox chan *Envelope
	cleanup func(c context.Context) error
}

func (s *Subscription) Mailbox() <-chan *Envelope {
	return s.mailbox
}

func (s *Subscription) Unsubscribe(c context.Context) error {
	return s.cleanup(c)
}

func New(co *discovery.Coordinator) (*Nexus, error) {
	server := grpc.NewServer()
	nx := &Nexus{
		mu:              sync.Mutex{},
		co:              co,
		server:          server,
		listeners:       make(map[string]*Subscription),
		clientsAndConns: make(map[string]*clientAndConn),
	}
	RegisterWireServer(server, nx)
	return nx, nil
}

type Nexus struct {
	mu              sync.Mutex
	co              *discovery.Coordinator
	server          *grpc.Server
	listeners       map[string]*Subscription
	clientsAndConns map[string]*clientAndConn
}

func (nx *Nexus) Start(address string) error {
	listener, err := net.Listen("tcp", address)
	if err != nil {
		return err
	}
	return nx.server.Serve(listener)
}

func (nx *Nexus) Stop() {
	nx.mu.Lock()
	defer nx.mu.Unlock()

	for _, cc := range nx.clientsAndConns {
		cc.conn.Close()
	}

	nx.server.Stop()
}

func (nx *Nexus) Process(c context.Context, req *Gram) (*Gram, error) {
	sub, err := nx.subscription(req.Namespace, req.Receiver)
	if err != nil {
		return nil, err
	}

	// Write the bytes of the request into the byte
	// buffer for decoding.
	var buf bytes.Buffer
	n, err := buf.Write(req.Data)
	if err != nil {
		return nil, err
	}
	if n != len(req.Data) {
		return nil, io.ErrUnexpectedEOF
	}

	// Decode the request into an actual
	// type.
	env := &Envelope{}
	dec := gob.NewDecoder(&buf)
	err = dec.Decode(env)
	if err != nil {
		return nil, err
	}
	env.response = make(chan []byte)

	// Send the filled envelope to the actual
	// receiver. Also note that the receiver
	// can stop listenting when it wants, so
	// some defualt or timeout always needs
	// to exist here.
	select {
	case sub.mailbox <- env:
	default:
		return nil, ErrReceiverBusy
	}

	// Wait for the receiver to send back a
	// reply, or the context to finish.
	select {
	case <-c.Done():
		return nil, ErrContextFinished
	case data := <-env.response:
		return &Gram{
			Data: data,
		}, nil
	}
}

// Request a response for the given message. The response is in the returned envelope.
func (nx *Nexus) Request(c context.Context, namespace, receiver string, msg interface{}) (*Envelope, error) {
	env := &Envelope{
		Msg: msg,
	}

	key := makeKey(namespace, receiver)

	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	err := enc.Encode(env)
	if err != nil {
		return nil, err
	}

	client, err := nx.client(c, key)
	if err != nil {
		return nil, err
	}

	req := &Gram{
		Ver:       Gram_V1,
		Enc:       Gram_Gob,
		Data:      buf.Bytes(),
		Receiver:  receiver,
		Namespace: namespace,
	}
	res, err := client.Process(c, req)
	if err != nil {
		return nil, err
	}

	buf.Reset()
	n, err := buf.Write(res.Data)
	if err != nil {
		return nil, err
	}
	if n != len(res.Data) {
		return nil, io.ErrUnexpectedEOF
	}

	env = &Envelope{}
	dec := gob.NewDecoder(&buf)
	err = dec.Decode(env)
	if err != nil {
		return nil, err
	}

	return env, nil
}

// Subscribe for requests under the given namespace and receiver name.
func (nx *Nexus) Subscribe(c context.Context, namespace, receiver string, mailboxSize int) (*Subscription, error) {
	nx.mu.Lock()
	defer nx.mu.Unlock()

	key := makeKey(namespace, receiver)

	_, ok := nx.listeners[key]
	if !ok {
		err := nx.co.RegisterReceiver(c, key)
		if err != nil {
			return nil, err
		}
		mailbox := make(chan *Envelope, mailboxSize)
		cleanup := func(c context.Context) error {
			nx.mu.Lock()
			defer nx.mu.Unlock()
			delete(nx.listeners, key)
			return nx.co.DeregisterReceiver(c, key)
		}
		sub := &Subscription{
			mailbox: mailbox,
			cleanup: cleanup,
		}
		nx.listeners[key] = sub
		return sub, nil
	}

	return nil, ErrAlreadySubscribed
}

func (nx *Nexus) subscription(namespace, receiver string) (*Subscription, error) {
	nx.mu.Lock()
	defer nx.mu.Unlock()

	key := makeKey(namespace, receiver)

	sub, ok := nx.listeners[key]
	if !ok {
		return nil, ErrUnknownReceiver
	}
	return sub, nil
}

func (nx *Nexus) client(c context.Context, key string) (WireClient, error) {
	nx.mu.Lock()
	defer nx.mu.Unlock()

	address, err := nx.co.FindAddress(c, key)
	if err != nil {
		return nil, err
	}

	cc, ok := nx.clientsAndConns[address]
	if !ok {
		conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBackoffMaxDelay(1*time.Minute), grpc.WithBlock())
		if err != nil {
			return nil, err
		}
		client := NewWireClient(conn)
		cc = &clientAndConn{
			conn:   conn,
			client: client,
		}
		nx.clientsAndConns[address] = cc
	}
	return cc.client, nil
}

func makeKey(namespace, receiver string) string {
	return fmt.Sprintf("/%v/%v", namespace, receiver)
}
