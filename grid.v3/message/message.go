package message

import (
	"bytes"
	"context"
	"encoding/gob"
	"fmt"
	"io"
	"net"
	"sync"
	"time"

	"github.com/lytics/grid/grid.v3/discovery"
	netcontext "golang.org/x/net/context"
	"google.golang.org/grpc"
)

const Ack = "__ACK__"

var (
	ErrInvalidAddress    = fmt.Errorf("invalid hostname")
	ErrContextFinished   = fmt.Errorf("context finished")
	ErrReceiverBusy      = fmt.Errorf("receiver busy")
	ErrAlreadySubscribed = fmt.Errorf("already subscribed")
	ErrUnknownHost       = fmt.Errorf("unknown host")
	ErrUnknownReceiver   = fmt.Errorf("unknown receiver")
)

type clientAndConn struct {
	conn   *grpc.ClientConn
	client WireClient
}

type Envelope struct {
	Msg      interface{}
	context  context.Context
	response chan []byte
}

func (env *Envelope) Context() context.Context {
	if env.response == nil {
		panic("only received envelopes may call context")
	}
	return env.context
}

func (env *Envelope) Ack() {
	if env.response == nil {
		panic("only received envelopes may call ack")
	}
	env.Respond(Ack)
}

func (env *Envelope) Respond(msg interface{}) error {
	if env.response == nil {
		panic("only received envelopes may call respond")
	}

	res := &Envelope{
		Msg: msg,
	}

	// Encode the message here, eg: in the Envelope, rather
	// than in Messenger, because it should be done by the
	// receiver's go-routine, otherwise there is a risk
	// that pointers in the message might actuall need
	// locking to be read-safe.
	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	err := enc.Encode(res)
	if err != nil {
		return err
	}

	// Send the response bytes. Again, the bytes need
	// to be generated by the receiver's go-routine.
	env.response <- buf.Bytes()
	return nil
}

type Subscription struct {
	mailbox chan *Envelope
	cleanup func(c context.Context) error
}

func (s *Subscription) Mailbox() <-chan *Envelope {
	return s.mailbox
}

func (s *Subscription) Unsubscribe(c context.Context) error {
	return s.cleanup(c)
}

func New(co *discovery.Coordinator) (*Messenger, error) {
	server := grpc.NewServer()
	m := &Messenger{
		mu:              sync.Mutex{},
		co:              co,
		server:          server,
		addresses:       make(map[string]string),
		listeners:       make(map[string]*Subscription),
		clientsAndConns: make(map[string]*clientAndConn),
	}
	RegisterWireServer(server, m)
	return m, nil
}

type Messenger struct {
	mu              sync.Mutex
	co              *discovery.Coordinator
	server          *grpc.Server
	addresses       map[string]string
	listeners       map[string]*Subscription
	clientsAndConns map[string]*clientAndConn
}

func (me *Messenger) Start(address string) error {
	listener, err := net.Listen("tcp", address)
	if err != nil {
		return err
	}
	return me.server.Serve(listener)
}

func (me *Messenger) Stop() {
	me.mu.Lock()
	defer me.mu.Unlock()

	for _, cc := range me.clientsAndConns {
		cc.conn.Close()
	}

	me.server.Stop()
}

func (me *Messenger) Process(c netcontext.Context, req *Gram) (*Gram, error) {
	sub, err := me.subscription(req.Receiver)
	if err != nil {
		return nil, err
	}

	// Write the bytes of the request into the byte
	// buffer for decoding.
	var buf bytes.Buffer
	n, err := buf.Write(req.Data)
	if err != nil {
		return nil, err
	}
	if n != len(req.Data) {
		return nil, io.ErrUnexpectedEOF
	}

	// Decode the request into an actual
	// type.
	env := &Envelope{}
	dec := gob.NewDecoder(&buf)
	err = dec.Decode(env)
	if err != nil {
		return nil, err
	}
	env.context = context.WithValue(c, "", "")
	env.response = make(chan []byte)

	// Send the filled envelope to the actual
	// receiver. Also note that the receiver
	// can stop listenting when it wants, so
	// some defualt or timeout always needs
	// to exist here.
	select {
	case sub.mailbox <- env:
	default:
		return nil, ErrReceiverBusy
	}

	// Wait for the receiver to send back a
	// reply, or the context to finish.
	select {
	case <-c.Done():
		return nil, ErrContextFinished
	case data := <-env.response:
		return &Gram{
			Data: data,
		}, nil
	}
}

// Request a response for the given message. The response is in the returned envelope.
func (me *Messenger) Request(c context.Context, receiver string, msg interface{}) (*Envelope, error) {
	env := &Envelope{
		Msg: msg,
	}

	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	err := enc.Encode(env)
	if err != nil {
		return nil, err
	}

	client, err := me.wireClient(c, receiver)
	if err != nil {
		return nil, err
	}

	req := &Gram{
		Ver:      Gram_V1,
		Enc:      Gram_Gob,
		Data:     buf.Bytes(),
		Receiver: receiver,
	}
	res, err := client.Process(c, req)
	if err != nil {
		return nil, err
	}

	buf.Reset()
	n, err := buf.Write(res.Data)
	if err != nil {
		return nil, err
	}
	if n != len(res.Data) {
		return nil, io.ErrUnexpectedEOF
	}

	env = &Envelope{}
	dec := gob.NewDecoder(&buf)
	err = dec.Decode(env)
	if err != nil {
		return nil, err
	}

	return env, nil
}

// Subscribe for requests under the given receiver name.
func (me *Messenger) Subscribe(c context.Context, receiver string, mailboxSize int) (*Subscription, error) {
	me.mu.Lock()
	defer me.mu.Unlock()

	_, ok := me.listeners[receiver]
	if !ok {
		err := me.co.Register(c, receiver)
		if err != nil {
			return nil, err
		}
		mailbox := make(chan *Envelope, mailboxSize)
		cleanup := func(c context.Context) error {
			me.mu.Lock()
			defer me.mu.Unlock()
			delete(me.listeners, receiver)
			return me.co.Deregister(c, receiver)
		}
		sub := &Subscription{
			mailbox: mailbox,
			cleanup: cleanup,
		}
		me.listeners[receiver] = sub
		return sub, nil
	}

	return nil, ErrAlreadySubscribed
}

func (me *Messenger) subscription(receiver string) (*Subscription, error) {
	me.mu.Lock()
	defer me.mu.Unlock()

	sub, ok := me.listeners[receiver]
	if !ok {
		return nil, ErrUnknownReceiver
	}
	return sub, nil
}

func (me *Messenger) wireClient(c context.Context, receiver string) (WireClient, error) {
	me.mu.Lock()
	defer me.mu.Unlock()

	address, ok := me.addresses[receiver]
	if !ok {
		reg, err := me.co.FindRegistration(c, receiver)
		if err != nil {
			return nil, err
		}
		address = reg.Address
		me.addresses[receiver] = address
	}

	cc, ok := me.clientsAndConns[address]
	if !ok {
		conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBackoffMaxDelay(1*time.Minute), grpc.WithBlock())
		if err != nil {
			return nil, err
		}
		client := NewWireClient(conn)
		cc = &clientAndConn{
			conn:   conn,
			client: client,
		}
		me.clientsAndConns[address] = cc
	}
	return cc.client, nil
}
