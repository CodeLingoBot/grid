package message

import (
	"bytes"
	"context"
	"encoding/gob"
	"fmt"
	"io"
	"net"
	"sync"
	"time"

	"github.com/lytics/grid/grid.v3/discovery"
	netcontext "golang.org/x/net/context"
	"google.golang.org/grpc"
)

const Ack = "__ACK__"

var (
	ErrInvalidAddress      = fmt.Errorf("invalid hostname")
	ErrContextFinished     = fmt.Errorf("context finished")
	ErrReceiverBusy        = fmt.Errorf("receiver busy")
	ErrAlreadySubscribed   = fmt.Errorf("already subscribed")
	ErrUnknownHost         = fmt.Errorf("unknown host")
	ErrUnknownSubscription = fmt.Errorf("unknown receiver")
	ErrMessengerStopping   = fmt.Errorf("messenger stopping")
)

type clientAndConn struct {
	conn   *grpc.ClientConn
	client WireClient
}

// Envelope for delivered request and response messages.
type Envelope struct {
	Msg      interface{}
	context  context.Context
	response chan []byte
}

// Context of envelope's request.
func (env *Envelope) Context() context.Context {
	if env.response == nil {
		panic("only received envelopes may call context")
	}
	return env.context
}

// Ack envelope delivery, same as responding with Respond
// and constant "Ack".
func (env *Envelope) Ack() {
	if env.response == nil {
		panic("only received envelopes may call ack")
	}
	env.Respond(Ack)
}

// Respond to envelope delivery with a message.
func (env *Envelope) Respond(msg interface{}) error {
	if env.response == nil {
		panic("only received envelopes may call respond")
	}

	res := &Envelope{
		Msg: msg,
	}

	// Encode the message here, eg: in the Envelope, rather
	// than in Messenger, because it should be done by the
	// receiver's go-routine, otherwise there is a risk
	// that pointers in the message might actuall need
	// locking to be read-safe.
	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	err := enc.Encode(res)
	if err != nil {
		return err
	}

	// Send the response bytes. Again, the bytes need
	// to be generated by the receiver's go-routine.
	env.response <- buf.Bytes()
	return nil
}

// Subscription for message on a particular topic name.
type Subscription struct {
	mailbox chan *Envelope
	cleanup func() error
}

// Mailbox of incoming requests for this subscription.
func (s *Subscription) Mailbox() <-chan *Envelope {
	return s.mailbox
}

// Unsubscribe from this subscription.
func (s *Subscription) Unsubscribe() error {
	return s.cleanup()
}

// New messenger.
func New(co *discovery.Coordinator) (*Messenger, error) {
	server := grpc.NewServer()
	m := &Messenger{
		mu:              sync.Mutex{},
		co:              co,
		server:          server,
		stopped:         make(chan struct{}),
		addresses:       make(map[string]string),
		subscriptions:   make(map[string]*Subscription),
		clientsAndConns: make(map[string]*clientAndConn),
	}
	RegisterWireServer(server, m)
	return m, nil
}

// Messenger is a bi-directional request and reply client
// and server.
type Messenger struct {
	mu              sync.Mutex
	co              *discovery.Coordinator
	server          *grpc.Server
	stopped         chan struct{}
	stopping        bool
	addresses       map[string]string
	subscriptions   map[string]*Subscription
	clientsAndConns map[string]*clientAndConn
}

// Serve the messenger listener.
func (me *Messenger) Serve() error {
	listener, err := net.Listen("tcp", me.co.Address())
	if err != nil {
		return err
	}

	return me.server.Serve(listener)
}

// Stop the messanger.
func (me *Messenger) Stop() {
	func() {
		me.mu.Lock()
		defer me.mu.Unlock()
		me.stopping = true
	}()

	<-me.stopped
	me.server.Stop()
}

// Process a request and return a response. Implements the interface for
// gRPC definition of the wire service.
func (me *Messenger) Process(c netcontext.Context, req *Gram) (*Gram, error) {
	sub, err := me.subscription(req.Receiver)
	if err != nil {
		return nil, err
	}

	// Write the bytes of the request into the byte
	// buffer for decoding.
	var buf bytes.Buffer
	n, err := buf.Write(req.Data)
	if err != nil {
		return nil, err
	}
	if n != len(req.Data) {
		return nil, io.ErrUnexpectedEOF
	}

	// Decode the request into an actual
	// type.
	env := &Envelope{}
	dec := gob.NewDecoder(&buf)
	err = dec.Decode(env)
	if err != nil {
		return nil, err
	}
	env.context = context.WithValue(c, "", "")
	env.response = make(chan []byte)

	// Send the filled envelope to the actual
	// receiver. Also note that the receiver
	// can stop listenting when it wants, so
	// some defualt or timeout always needs
	// to exist here.
	select {
	case sub.mailbox <- env:
	default:
		return nil, ErrReceiverBusy
	}

	// Wait for the receiver to send back a
	// reply, or the context to finish.
	select {
	case <-c.Done():
		return nil, ErrContextFinished
	case data := <-env.response:
		return &Gram{
			Data: data,
		}, nil
	}
}

// Request a response for the given message. The response is in the returned envelope.
func (me *Messenger) Request(timeout time.Duration, receiver string, msg interface{}) (*Envelope, error) {
	timeoutC, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	return me.RequestC(timeoutC, receiver, msg)
}

// RequestC a response for the given message. The response is in the returned envelope.
func (me *Messenger) RequestC(c context.Context, receiver string, msg interface{}) (*Envelope, error) {
	env := &Envelope{
		Msg: msg,
	}

	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	err := enc.Encode(env)
	if err != nil {
		return nil, err
	}

	client, err := me.wireClient(c, receiver)
	if err != nil {
		return nil, err
	}

	req := &Gram{
		Ver:      Gram_V1,
		Enc:      Gram_Gob,
		Data:     buf.Bytes(),
		Receiver: receiver,
	}
	res, err := client.Process(c, req)
	if err != nil {
		return nil, err
	}

	buf.Reset()
	n, err := buf.Write(res.Data)
	if err != nil {
		return nil, err
	}
	if n != len(res.Data) {
		return nil, io.ErrUnexpectedEOF
	}

	env = &Envelope{}
	dec := gob.NewDecoder(&buf)
	err = dec.Decode(env)
	if err != nil {
		return nil, err
	}

	return env, nil
}

// Subscribe for requests under the given receiver name.
func (me *Messenger) Subscribe(name string, mailboxSize int) (*Subscription, error) {
	me.mu.Lock()
	defer me.mu.Unlock()

	if me.stopping {
		return nil, ErrMessengerStopping
	}

	_, ok := me.subscriptions[name]
	if !ok {
		timeout, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		err := me.co.Register(timeout, name)
		cancel()
		if err != nil {
			return nil, err
		}

		mailbox := make(chan *Envelope, mailboxSize)
		cleanup := func() error {
			me.mu.Lock()
			defer me.mu.Unlock()

			// Immediately delete the subscription so that no one
			// can send to it, at least from this host.
			delete(me.subscriptions, name)

			// Deregister the name.
			timeout, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			err := me.co.Deregister(timeout, name)
			cancel()

			// Check if this was actually the very last subscription
			// to be cleaned up when stopping. If it is the last then
			// the messenger can be considered stopped.
			if me.stopping && len(me.subscriptions) == 0 {
				close(me.stopped)
			}

			// Return any error from the deregister call.
			return err
		}
		sub := &Subscription{
			mailbox: mailbox,
			cleanup: cleanup,
		}
		me.subscriptions[name] = sub
		return sub, nil
	}

	return nil, ErrAlreadySubscribed
}

func (me *Messenger) subscription(name string) (*Subscription, error) {
	me.mu.Lock()
	defer me.mu.Unlock()

	sub, ok := me.subscriptions[name]
	if !ok {
		return nil, ErrUnknownSubscription
	}
	return sub, nil
}

func (me *Messenger) wireClient(c context.Context, receiver string) (WireClient, error) {
	me.mu.Lock()
	defer me.mu.Unlock()

	address, ok := me.addresses[receiver]
	if !ok {
		reg, err := me.co.FindRegistration(c, receiver)
		if err != nil {
			return nil, err
		}
		address = reg.Address
		me.addresses[receiver] = address
	}

	cc, ok := me.clientsAndConns[address]
	if !ok {
		conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBackoffMaxDelay(1*time.Minute), grpc.WithBlock())
		if err != nil {
			return nil, err
		}
		client := NewWireClient(conn)
		cc = &clientAndConn{
			conn:   conn,
			client: client,
		}
		me.clientsAndConns[address] = cc
	}
	return cc.client, nil
}
